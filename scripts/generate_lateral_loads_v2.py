#!/usr/bin/env python3
"""
Generate Lateral Loads - Rainfall-Driven Smart Version (v2)
============================================================

This script automates C-GEM lateral input generation using GLOBAL DATASETS,
eliminating the need for arbitrary "calibration guessing."

PHILOSOPHY:
===========
The user provides:
1. Land Use Map (from JAXA/Sentinel satellite data)
2. Monthly Rainfall (from WorldClim/TRMM/ERA5 or climate presets)

The script computes:
- Base loads from JAXA land use → Emission factors
- Seasonal factors from rainfall → Runoff physics
- First-flush effects from wash-off power law

INPUTS (All globally available):
================================
1. Land Use Map (JAXA ALOS-2/PALSAR or Sentinel-2)
   - Can be generated by generate_synthetic_landuse.py for demo
   
2. Monthly Rainfall (mm) - One of:
   - Climate preset (Mekong, RedRiver, Ganges, etc.)
   - Custom 12-value array from WorldClim/ERA5
   - Auto-fetch from API (future feature)

OUTPUTS:
========
1. lateral_sources.csv        - Base loads (dry season reference)
2. lateral_seasonal_factors.csv - Monthly Q and concentration multipliers
3. point_sources.csv          - City sewage (optional)

SCIENTIFIC BASIS:
=================
- Export Coefficients: Garnier et al. (2005), Kroeze et al. (2002)
- Runoff-Concentration: Horton overland flow + first-flush wash-off
- JAXA Mapping: Based on ALOS-2 25m land cover classification

COMPARISON WITH OTHER MODELS:
=============================
| Model    | Method                  | This Script's Equivalent |
|----------|-------------------------|-------------------------|
| SWAT     | Process-based soil/crop | Simplified EMC approach |
| Delft3D  | Time-varying .tim files | seasonal_factors.csv    |
| MIKE     | NAM rainfall-runoff     | Rainfall → Q_Factor     |
| NEWS     | Export coefficients     | JAXA_EMISSIONS table    |

References:
- Garnier et al. (2005) Biogeochemistry 77, 213-242
- MRC (2018) State of Basin Report - Mekong hydrology
- JAXA ALOS-2 Land Use/Cover Map documentation

Author: Nguyen Truong An
Date: December 2025
"""

import argparse
import os
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import pandas as pd
import numpy as np
from datetime import datetime

# ==============================================================================
# CONFIGURATION
# ==============================================================================

SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent
DEFAULT_CASE_DIR = PROJECT_ROOT / "INPUT" / "Cases" / "Mekong_Delta_Full"

# Grid spacing (from topology)
DX_M = 2000.0  # Grid cell size [m]

# ==============================================================================
# GLOBAL DATASETS: JAXA LAND USE → EMISSION FACTORS
# ==============================================================================
# 
# This table maps JAXA LULC classes to C-GEM water quality parameters.
# EMC = Event Mean Concentration (mg/L) represents pollution intensity.
# Runoff_C = Rational method runoff coefficient (dimensionless).
#
# References:
# - Urban EMC: Burton & Pitt (2002) Stormwater Effects Handbook
# - Rice EMC: Yan et al. (2003) Agriculture, Ecosystems & Environment
# - Aquaculture: Páez-Osuna (2001) Environment International
# - Mangrove: Alongi (2014) Annual Review of Marine Science

JAXA_EMISSIONS = {
    # Land Use Type: {Species: EMC (mg/L), Runoff_C: coefficient}
    "Urban": {
        "NH4": 10.0,    # Sewage leakage, pet waste
        "NO3": 3.0,     # Fertilized lawns, septic
        "PO4": 1.5,     # Detergents, sewage
        "TOC": 50.0,    # Organic waste, litter
        "DIC": 20.0,    # Concrete weathering
        "SPM": 150.0,   # Construction sediment
        "Runoff_C": 0.85,  # High imperviousness
    },
    "Rice": {
        "NH4": 2.5,     # Urea fertilizer breakdown
        "NO3": 6.0,     # Nitrified fertilizer
        "PO4": 0.8,     # Phosphate fertilizer
        "TOC": 20.0,    # Straw decomposition
        "DIC": 15.0,    # Carbonate dissolution
        "SPM": 80.0,    # Tillage erosion
        "Runoff_C": 0.40,  # Bunded paddies retain water
    },
    "Aqua": {
        "NH4": 8.0,     # Fish excretion, uneaten feed
        "NO3": 3.0,     # Some nitrification
        "PO4": 2.0,     # Feed phosphorus
        "TOC": 80.0,    # High organic load
        "DIC": 30.0,    # Respiration CO2
        "SPM": 200.0,   # Pond sediment resuspension
        "Runoff_C": 0.70,  # Direct discharge during harvest
    },
    "Mangrove": {
        "NH4": 0.2,     # N sink (denitrification)
        "NO3": 0.1,     # Strong N sink
        "PO4": 0.1,     # P burial
        "TOC": 100.0,   # Major carbon export (tidal)
        "DIC": 60.0,    # Respiration + carbonate
        "SPM": 50.0,    # Fine sediment trap
        "Runoff_C": 0.90,  # Tidal flushing
    },
    "Fruit": {
        "NH4": 3.0,     # Moderate fertilizer
        "NO3": 8.0,     # Higher NO3 from orchards
        "PO4": 1.0,     # Phosphate application
        "TOC": 25.0,    # Leaf litter, prunings
        "DIC": 12.0,    # Soil respiration
        "SPM": 60.0,    # Exposed soil erosion
        "Runoff_C": 0.30,  # Tree cover reduces runoff
    },
    "Forest": {
        "NH4": 0.3,     # Minimal
        "NO3": 0.5,     # Natural background
        "PO4": 0.05,    # Weathering only
        "TOC": 15.0,    # Leaf litter leachate
        "DIC": 8.0,     # Soil respiration
        "SPM": 20.0,    # Low erosion
        "Runoff_C": 0.15,  # High infiltration
    },
}

# ==============================================================================
# CLIMATE PRESETS: MONTHLY RAINFALL (mm)
# ==============================================================================
#
# These presets allow users to quickly set up models for common regions.
# Data sources: WorldClim, TRMM, ERA5 climatology
# Format: [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]

CLIMATE_PRESETS = {
    # Mekong Delta (Southern Vietnam) - MRC data
    # Peak: September, Dry: Jan-Apr
    "Mekong": {
        "rainfall_mm": [15, 8, 20, 55, 180, 260, 290, 310, 340, 270, 130, 45],
        "description": "Mekong Delta, Vietnam (Monsoon tropical)",
        "dry_months": [0, 1, 2, 3],  # Jan-Apr (0-indexed)
    },
    
    # Red River Delta (Northern Vietnam) - Earlier monsoon
    "RedRiver": {
        "rainfall_mm": [20, 28, 45, 95, 190, 260, 290, 320, 220, 120, 55, 25],
        "description": "Red River Delta, Vietnam (Subtropical monsoon)",
        "dry_months": [0, 1, 2, 11],  # Jan-Mar, Dec
    },
    
    # Saigon-Dong Nai (Southern Vietnam)
    "SaigonDongNai": {
        "rainfall_mm": [12, 5, 15, 50, 200, 280, 300, 290, 320, 260, 120, 40],
        "description": "Saigon-Dong Nai basin, Vietnam",
        "dry_months": [0, 1, 2, 3],
    },
    
    # Ganges-Brahmaputra Delta (Bangladesh/India)
    "Ganges": {
        "rainfall_mm": [10, 20, 35, 60, 150, 280, 350, 320, 280, 160, 40, 15],
        "description": "Ganges-Brahmaputra Delta, Bangladesh",
        "dry_months": [0, 1, 2, 11],
    },
    
    # Niger Delta (Nigeria) - Bimodal rainfall
    "Niger": {
        "rainfall_mm": [25, 40, 100, 180, 250, 350, 380, 300, 340, 250, 80, 30],
        "description": "Niger Delta, Nigeria (Equatorial)",
        "dry_months": [0, 1, 11],
    },
    
    # Irrawaddy (Myanmar)
    "Irrawaddy": {
        "rainfall_mm": [5, 10, 25, 50, 200, 450, 550, 500, 350, 180, 60, 15],
        "description": "Irrawaddy Delta, Myanmar (Strong monsoon)",
        "dry_months": [0, 1, 2, 3, 11],
    },
    
    # Mediterranean (dry summer) - for comparison
    "Mediterranean": {
        "rainfall_mm": [80, 70, 55, 45, 30, 15, 8, 12, 35, 70, 90, 95],
        "description": "Mediterranean climate (wet winter)",
        "dry_months": [5, 6, 7],  # Jun-Aug
    },
}

# ==============================================================================
# PHYSICS: RAINFALL → SEASONAL FACTORS
# ==============================================================================

def calculate_seasonal_factors(
    rainfall_mm: List[float],
    dry_months: List[int] = None,
    wash_off_exponent: float = 0.25,
    dilution_threshold: float = 5.0,
) -> pd.DataFrame:
    """
    Convert monthly rainfall (mm) to Q and concentration factors.
    
    Physics:
    --------
    1. Flow Factor (Q_Factor):
       Q_ratio = Rain_month / Rain_dry_base
       This represents relative runoff intensity.
       
    2. Concentration Factor (C_Factor):
       Uses wash-off power law: C = a * Q^b
       - Rising limb (Q < threshold): First flush effect, C increases
       - Peak flow (Q > threshold): Dilution effect, C decreases
       
    Parameters:
    -----------
    rainfall_mm : list of 12 floats
        Monthly rainfall [Jan, Feb, ..., Dec]
    dry_months : list of int, optional
        Indices of dry season months (0=Jan, 11=Dec). Default: [0,1,2]
    wash_off_exponent : float
        Power law exponent for first flush (typically 0.2-0.4)
    dilution_threshold : float
        Q_factor above which dilution dominates
        
    Returns:
    --------
    DataFrame with columns: Month, Rain_mm, Q_Factor, NH4_Factor, NO3_Factor, 
                           PO4_Factor, TOC_Factor, SPM_Factor
    """
    if dry_months is None:
        dry_months = [0, 1, 2]  # Jan-Mar default
    
    # Calculate dry season base rainfall
    dry_rain = [rainfall_mm[i] for i in dry_months]
    base_rain = max(5.0, np.mean(dry_rain))  # Minimum 5mm to avoid division by zero
    
    records = []
    month_names = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    
    for month_idx, rain in enumerate(rainfall_mm):
        # 1. Flow Factor = Rain / Base_Rain (with minimum of 1.0)
        q_factor = max(1.0, rain / base_rain)
        
        # 2. Concentration factors based on wash-off physics
        # Different species respond differently to flow
        
        if q_factor < dilution_threshold:
            # Rising limb: First flush wash-off (concentration increases with flow)
            # C ~ Q^b where b > 0
            base_c_factor = q_factor ** wash_off_exponent
            
            nh4_factor = base_c_factor * 1.0    # NH4: moderate wash-off
            no3_factor = base_c_factor * 0.8    # NO3: less particulate
            po4_factor = base_c_factor * 1.2    # PO4: more particulate-bound
            toc_factor = base_c_factor * 1.3    # TOC: strong wash-off
            spm_factor = base_c_factor * 1.5    # SPM: strongest wash-off
            
        else:
            # Peak flow: Dilution dominates
            # C ~ Q^(-c) where c > 0
            peak_c = dilution_threshold ** wash_off_exponent
            dilution_power = 0.4
            
            dilution = (dilution_threshold / q_factor) ** dilution_power
            
            nh4_factor = peak_c * dilution * 0.9
            no3_factor = peak_c * dilution * 0.7   # Strong dilution
            po4_factor = peak_c * dilution * 1.0
            toc_factor = peak_c * 1.1              # TOC stays high (organic flush)
            spm_factor = peak_c * 1.3              # SPM continues increasing
        
        # Determine season
        if month_idx in dry_months:
            season = "dry"
        elif q_factor > 3.0:
            season = "wet"
        else:
            season = "transition"
        
        records.append({
            "Month": month_idx + 1,
            "Month_Name": month_names[month_idx],
            "Season": season,
            "Rain_mm": rain,
            "Q_Factor": round(q_factor, 3),
            "NH4_Factor": round(nh4_factor, 3),
            "NO3_Factor": round(no3_factor, 3),
            "PO4_Factor": round(po4_factor, 3),
            "TOC_Factor": round(toc_factor, 3),
            "SPM_Factor": round(spm_factor, 3),
        })
    
    return pd.DataFrame(records)


def calculate_daily_factors(
    monthly_factors: pd.DataFrame,
    duration_days: int = 365,
    start_month: int = 1,
) -> pd.DataFrame:
    """
    Interpolate monthly factors to daily resolution for C-code.
    
    Uses smooth interpolation to avoid step changes at month boundaries.
    
    Parameters:
    -----------
    monthly_factors : DataFrame
        Output from calculate_seasonal_factors()
    duration_days : int
        Number of days to generate
    start_month : int
        Starting month (1-12)
        
    Returns:
    --------
    DataFrame with columns: Day, Month, Q_Factor, NH4_Factor, etc.
    """
    # Days per month (non-leap year)
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    # Build daily factors with linear interpolation
    records = []
    current_month = start_month - 1  # 0-indexed
    day_in_month = 0
    
    for day in range(duration_days):
        # Get current and next month factors
        curr_factors = monthly_factors.iloc[current_month]
        next_month = (current_month + 1) % 12
        next_factors = monthly_factors.iloc[next_month]
        
        # Linear interpolation weight
        month_progress = day_in_month / days_in_month[current_month]
        
        # Interpolate each factor
        record = {
            "Day": day,
            "Day_of_Year": (day + (start_month - 1) * 30) % 365,
            "Month": current_month + 1,
            "Season": curr_factors["Season"],
        }
        
        for col in ["Q_Factor", "NH4_Factor", "NO3_Factor", "PO4_Factor", 
                    "TOC_Factor", "SPM_Factor"]:
            interp_val = (1 - month_progress) * curr_factors[col] + \
                         month_progress * next_factors[col]
            record[col] = round(interp_val, 4)
        
        records.append(record)
        
        # Advance day
        day_in_month += 1
        if day_in_month >= days_in_month[current_month]:
            day_in_month = 0
            current_month = next_month
    
    return pd.DataFrame(records)


# ==============================================================================
# SPATIAL: LAND USE MAP → BASE LOADS
# ==============================================================================

def load_landuse_map(case_dir: Path) -> pd.DataFrame:
    """Load the land use map CSV."""
    path = case_dir / "landuse_map.csv"
    if not path.exists():
        raise FileNotFoundError(
            f"Land use map not found: {path}\n"
            "Run generate_synthetic_landuse.py first, or provide JAXA/Sentinel data."
        )
    return pd.read_csv(path)


def calculate_base_loads(
    landuse_df: pd.DataFrame,
    base_runoff_rate: float = 0.002,  # m³/s/km² dry season baseflow
) -> pd.DataFrame:
    """
    Calculate base (dry season) lateral loads from land use.
    
    The output represents the "reference" load that will be multiplied
    by seasonal factors during simulation.
    
    Parameters:
    -----------
    landuse_df : DataFrame
        Land use map with columns: Branch, Distance_km, Segment_Area_km2,
        Pct_Urban, Pct_Rice, Pct_Aqua, Pct_Mangrove, Pct_Fruit
    base_runoff_rate : float
        Dry season runoff rate [m³/s/km²]
        
    Returns:
    --------
    DataFrame with columns: Branch, Segment_Index, Distance_km, Q_lat_base,
        NH4_conc_base, NO3_conc_base, etc. (concentrations in mg/L)
    """
    records = []
    
    for _, row in landuse_df.iterrows():
        branch = row["Branch"]
        dist_km = row["Distance_km"]
        area_km2 = row.get("Segment_Area_km2", 2.0)  # Default 2 km²
        
        # Calculate grid index
        segment_idx = int(dist_km * 1000 / DX_M)
        
        # Calculate composite EMC based on land use percentages
        # C_composite = Σ (Pct_i × EMC_i) / 100
        conc_mix = {sp: 0.0 for sp in ["NH4", "NO3", "PO4", "TOC", "DIC", "SPM"]}
        runoff_c_mix = 0.0
        
        for lu_type, emissions in JAXA_EMISSIONS.items():
            col_name = f"Pct_{lu_type}"
            if col_name in row and row[col_name] > 0:
                fraction = row[col_name] / 100.0
                for sp in conc_mix:
                    if sp in emissions:
                        conc_mix[sp] += fraction * emissions[sp]
                runoff_c_mix += fraction * emissions["Runoff_C"]
        
        # Ensure minimum runoff coefficient
        if runoff_c_mix < 0.1:
            runoff_c_mix = 0.1
        
        # Calculate base flow [m³/s] = Area × Runoff_rate × Runoff_C
        q_base = area_km2 * base_runoff_rate * runoff_c_mix
        
        # Identify polder zones (rice + aquaculture dominated)
        pct_polder = row.get("Pct_Rice", 0) + row.get("Pct_Aqua", 0)
        is_polder = pct_polder > 50.0
        
        records.append({
            "Branch": branch,
            "Segment_Index": segment_idx,
            "Distance_km": dist_km,
            "Area_km2": area_km2,
            "Runoff_C": round(runoff_c_mix, 3),
            "Is_Polder_Zone": is_polder,
            "Q_lat_base_m3_s": round(q_base, 6),
            "NH4_conc_base_mg_L": round(conc_mix["NH4"], 2),
            "NO3_conc_base_mg_L": round(conc_mix["NO3"], 2),
            "PO4_conc_base_mg_L": round(conc_mix["PO4"], 2),
            "TOC_conc_base_mg_L": round(conc_mix["TOC"], 2),
            "DIC_conc_base_mg_L": round(conc_mix["DIC"], 2),
            "SPM_conc_base_mg_L": round(conc_mix["SPM"], 2),
        })
    
    return pd.DataFrame(records)


# ==============================================================================
# POINT SOURCES: CITIES AND INDUSTRIAL DISCHARGES
# ==============================================================================

# Major cities in the Mekong Delta
POINT_SOURCES_MEKONG = {
    "Can_Tho": {
        "branch": "Hau_River",
        "distance_km": 80.0,
        "population": 1_500_000,
        "treatment_level": "primary",  # 30% removal
    },
    "My_Tho": {
        "branch": "My_Tho",
        "distance_km": 40.0,
        "population": 500_000,
        "treatment_level": "none",
    },
    "Ben_Tre": {
        "branch": "Ham_Luong",
        "distance_km": 45.0,
        "population": 200_000,
        "treatment_level": "none",
    },
    "Vinh_Long": {
        "branch": "Co_Chien",
        "distance_km": 60.0,
        "population": 150_000,
        "treatment_level": "none",
    },
}

# Per-capita emission rates (g/person/day)
# References: WHO guidelines, Metcalf & Eddy
PERCAPITA_EMISSIONS = {
    "NH4": 12.0,   # ~12g N/person/day
    "NO3": 1.0,    # Minimal (mostly NH4)
    "PO4": 2.0,    # ~2g P/person/day
    "TOC": 60.0,   # ~60g BOD/person/day → TOC
    "DIC": 30.0,   # Respiration CO2
    "SPM": 50.0,   # Fecal solids
}

# Treatment removal efficiencies
TREATMENT_REMOVAL = {
    "none": {"NH4": 0.0, "NO3": 0.0, "PO4": 0.0, "TOC": 0.0, "SPM": 0.0},
    "primary": {"NH4": 0.1, "NO3": 0.0, "PO4": 0.1, "TOC": 0.3, "SPM": 0.5},
    "secondary": {"NH4": 0.6, "NO3": 0.2, "PO4": 0.3, "TOC": 0.8, "SPM": 0.9},
    "tertiary": {"NH4": 0.9, "NO3": 0.8, "PO4": 0.9, "TOC": 0.95, "SPM": 0.95},
}


def generate_point_sources(
    point_source_dict: dict = None,
    per_capita_water_L_day: float = 150.0,
) -> pd.DataFrame:
    """
    Generate point source file for major cities.
    
    Parameters:
    -----------
    point_source_dict : dict, optional
        Dictionary of point sources (default: POINT_SOURCES_MEKONG)
    per_capita_water_L_day : float
        Per-capita wastewater generation [L/person/day]
        
    Returns:
    --------
    DataFrame with point source specifications
    """
    if point_source_dict is None:
        point_source_dict = POINT_SOURCES_MEKONG
    
    records = []
    
    for name, data in point_source_dict.items():
        pop = data["population"]
        treatment = data.get("treatment_level", "none")
        removal = TREATMENT_REMOVAL[treatment]
        
        # Calculate flow [m³/s]
        q_m3_s = pop * per_capita_water_L_day / 1000.0 / 86400.0
        
        # Calculate concentrations after treatment [mg/L]
        conc = {}
        for sp, per_cap in PERCAPITA_EMISSIONS.items():
            # Mass load [g/s] = pop × emission × (1 - removal) / 86400
            mass_g_s = pop * per_cap * (1 - removal.get(sp, 0)) / 86400.0
            # Concentration [mg/L] = mass [g/s] / flow [m³/s] × 1000 [L/m³]
            conc[sp] = mass_g_s / q_m3_s * 1000.0 if q_m3_s > 0 else 0.0
        
        segment_idx = int(data["distance_km"] * 1000 / DX_M)
        
        records.append({
            "Name": name,
            "Branch": data["branch"],
            "Segment_Index": segment_idx,
            "Distance_km": data["distance_km"],
            "Population": pop,
            "Treatment": treatment,
            "Q_m3_s": round(q_m3_s, 4),
            "NH4_mg_L": round(conc["NH4"], 1),
            "NO3_mg_L": round(conc["NO3"], 1),
            "PO4_mg_L": round(conc["PO4"], 1),
            "TOC_mg_L": round(conc["TOC"], 1),
            "DIC_mg_L": round(conc["DIC"], 1),
            "SPM_mg_L": round(conc["SPM"], 1),
        })
    
    return pd.DataFrame(records)


# ==============================================================================
# MAIN GENERATION FUNCTION
# ==============================================================================

def generate_all_files(
    case_dir: Path,
    climate: str = "Mekong",
    custom_rainfall: List[float] = None,
    duration_days: int = 365,
    include_point_sources: bool = True,
    base_runoff_rate: float = 0.002,
) -> Dict[str, pd.DataFrame]:
    """
    Generate all lateral load input files for C-GEM.
    
    Parameters:
    -----------
    case_dir : Path
        Case directory containing landuse_map.csv
    climate : str
        Climate preset name or "custom" for custom rainfall
    custom_rainfall : list, optional
        12 monthly rainfall values [mm] if climate="custom"
    duration_days : int
        Number of days for daily factor file
    include_point_sources : bool
        Whether to generate point sources file
    base_runoff_rate : float
        Dry season runoff [m³/s/km²]
        
    Returns:
    --------
    Dictionary of generated DataFrames
    """
    print("=" * 70)
    print("C-GEM LATERAL LOAD GENERATOR (Rainfall-Driven v2)")
    print("=" * 70)
    
    outputs = {}
    
    # -------------------------------------------------------------------------
    # 1. Get rainfall data
    # -------------------------------------------------------------------------
    if custom_rainfall is not None:
        if len(custom_rainfall) != 12:
            raise ValueError("custom_rainfall must have exactly 12 values")
        rainfall_mm = custom_rainfall
        dry_months = [0, 1, 2]  # Default dry months
        print(f"\nUsing CUSTOM rainfall data")
    elif climate in CLIMATE_PRESETS:
        preset = CLIMATE_PRESETS[climate]
        rainfall_mm = preset["rainfall_mm"]
        dry_months = preset["dry_months"]
        print(f"\nUsing climate preset: {climate}")
        print(f"  Description: {preset['description']}")
    else:
        raise ValueError(f"Unknown climate preset: {climate}. "
                        f"Available: {list(CLIMATE_PRESETS.keys())}")
    
    print(f"  Rainfall (mm): {rainfall_mm}")
    print(f"  Annual total: {sum(rainfall_mm)} mm")
    print(f"  Dry months: {[i+1 for i in dry_months]}")
    
    # -------------------------------------------------------------------------
    # 2. Generate seasonal factors
    # -------------------------------------------------------------------------
    print("\nCalculating seasonal factors from rainfall physics...")
    monthly_factors = calculate_seasonal_factors(rainfall_mm, dry_months)
    
    # Save monthly factors
    monthly_path = case_dir / "lateral_seasonal_factors.csv"
    monthly_factors.to_csv(monthly_path, index=False)
    outputs["monthly_factors"] = monthly_factors
    print(f"  Saved: {monthly_path}")
    
    # Show summary
    print("\n  Monthly Factors:")
    print(monthly_factors[["Month_Name", "Rain_mm", "Q_Factor", "NH4_Factor", 
                          "TOC_Factor"]].to_string(index=False))
    
    # Generate daily interpolated factors
    print(f"\n  Generating daily factors ({duration_days} days)...")
    daily_factors = calculate_daily_factors(monthly_factors, duration_days)
    daily_path = case_dir / "lateral_daily_factors.csv"
    daily_factors.to_csv(daily_path, index=False)
    outputs["daily_factors"] = daily_factors
    print(f"  Saved: {daily_path}")
    
    # -------------------------------------------------------------------------
    # 3. Generate base loads from land use
    # -------------------------------------------------------------------------
    print("\nLoading land use map...")
    try:
        landuse_df = load_landuse_map(case_dir)
        print(f"  Loaded {len(landuse_df)} segments from "
              f"{len(landuse_df['Branch'].unique())} branches")
    except FileNotFoundError as e:
        print(f"  Warning: {e}")
        print("  Skipping base load generation.")
        return outputs
    
    print("\nCalculating base loads from JAXA emissions...")
    base_loads = calculate_base_loads(landuse_df, base_runoff_rate)
    
    # Save base loads
    base_path = case_dir / "lateral_sources.csv"
    base_loads.to_csv(base_path, index=False)
    outputs["base_loads"] = base_loads
    print(f"  Saved: {base_path}")
    
    # Summary by branch
    print("\n  Base loads by branch (dry season reference):")
    summary = base_loads.groupby("Branch").agg({
        "Q_lat_base_m3_s": "sum",
        "Area_km2": "sum",
    })
    summary["Q_m3_day"] = summary["Q_lat_base_m3_s"] * 86400
    print(summary[["Area_km2", "Q_m3_day"]].round(1).to_string())
    
    # -------------------------------------------------------------------------
    # 4. Generate point sources
    # -------------------------------------------------------------------------
    if include_point_sources:
        print("\nGenerating point sources (cities)...")
        point_sources = generate_point_sources()
        
        point_path = case_dir / "point_sources.csv"
        point_sources.to_csv(point_path, index=False)
        outputs["point_sources"] = point_sources
        print(f"  Saved: {point_path}")
        
        print("\n  Point Sources:")
        print(point_sources[["Name", "Branch", "Population", "Q_m3_s", 
                            "NH4_mg_L", "TOC_mg_L"]].to_string(index=False))
    
    # -------------------------------------------------------------------------
    # 5. Final summary
    # -------------------------------------------------------------------------
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print("\nFiles generated:")
    print(f"  1. {monthly_path.name} - Monthly Q and concentration factors")
    print(f"  2. {daily_path.name} - Daily interpolated factors")
    print(f"  3. {base_path.name} - Base loads (dry season reference)")
    if include_point_sources:
        print(f"  4. {point_path.name} - City point sources")
    
    print("\nC-CODE USAGE:")
    print("  1. At initialization: Load lateral_sources.csv (base loads)")
    print("  2. At initialization: Load lateral_seasonal_factors.csv (monthly) OR")
    print("                        lateral_daily_factors.csv (daily interpolation)")
    print("  3. At each timestep:")
    print("     Q_lat = Q_lat_base × Q_Factor(month)")
    print("     C_lat = C_lat_base × Species_Factor(month)")
    
    return outputs


# ==============================================================================
# COMMAND LINE INTERFACE
# ==============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Generate rainfall-driven lateral loads for C-GEM",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Use Mekong climate preset (default)
  python generate_lateral_loads_v2.py
  
  # Use Red River climate
  python generate_lateral_loads_v2.py --climate RedRiver
  
  # Custom rainfall (12 values in mm)
  python generate_lateral_loads_v2.py --rainfall 10,5,15,40,150,250,300,320,350,280,100,30
  
  # Show available climate presets
  python generate_lateral_loads_v2.py --list-presets
  
  # Custom case directory
  python generate_lateral_loads_v2.py --case-dir INPUT/Cases/MyCase

Climate Presets Available:
  Mekong        - Mekong Delta, Vietnam (monsoon tropical)
  RedRiver      - Red River Delta, Vietnam (subtropical monsoon)
  SaigonDongNai - Saigon-Dong Nai basin, Vietnam
  Ganges        - Ganges-Brahmaputra Delta, Bangladesh
  Niger         - Niger Delta, Nigeria (equatorial)
  Irrawaddy     - Irrawaddy Delta, Myanmar (strong monsoon)
  Mediterranean - Mediterranean climate (dry summer)
        """
    )
    
    parser.add_argument(
        "--climate", "-c",
        type=str,
        default="Mekong",
        help="Climate preset name (default: Mekong)"
    )
    parser.add_argument(
        "--rainfall", "-r",
        type=str,
        default=None,
        help="Custom monthly rainfall as comma-separated values (12 values in mm)"
    )
    parser.add_argument(
        "--case-dir", "-d",
        type=str,
        default=None,
        help="Path to case directory"
    )
    parser.add_argument(
        "--duration",
        type=int,
        default=365,
        help="Duration in days for daily factor file (default: 365)"
    )
    parser.add_argument(
        "--no-point-sources",
        action="store_true",
        help="Skip point source generation"
    )
    parser.add_argument(
        "--list-presets",
        action="store_true",
        help="List available climate presets and exit"
    )
    parser.add_argument(
        "--base-runoff",
        type=float,
        default=0.002,
        help="Dry season base runoff rate [m³/s/km²] (default: 0.002)"
    )
    
    args = parser.parse_args()
    
    # List presets
    if args.list_presets:
        print("\nAvailable Climate Presets:")
        print("-" * 70)
        for name, preset in CLIMATE_PRESETS.items():
            print(f"\n{name}:")
            print(f"  Description: {preset['description']}")
            print(f"  Rainfall (mm): {preset['rainfall_mm']}")
            print(f"  Annual total: {sum(preset['rainfall_mm'])} mm")
            print(f"  Dry months: {[i+1 for i in preset['dry_months']]}")
        return
    
    # Parse custom rainfall
    custom_rainfall = None
    if args.rainfall:
        try:
            custom_rainfall = [float(x.strip()) for x in args.rainfall.split(",")]
            if len(custom_rainfall) != 12:
                raise ValueError("Must provide exactly 12 values")
        except Exception as e:
            print(f"Error parsing rainfall: {e}")
            return
    
    # Set case directory
    case_dir = Path(args.case_dir) if args.case_dir else DEFAULT_CASE_DIR
    
    # Generate files
    generate_all_files(
        case_dir=case_dir,
        climate=args.climate if custom_rainfall is None else "custom",
        custom_rainfall=custom_rainfall,
        duration_days=args.duration,
        include_point_sources=not args.no_point_sources,
        base_runoff_rate=args.base_runoff,
    )


if __name__ == "__main__":
    main()
