#!/usr/bin/env python3
"""
Generate Lateral Loads - Rainfall-Driven Smart Version (v2)
============================================================

This script automates C-GEM lateral input generation using GLOBAL DATASETS,
eliminating the need for arbitrary "calibration guessing."

PHILOSOPHY:
===========
The user provides:
1. Land Use Map (from JAXA/Sentinel satellite data)
2. Monthly Rainfall (from WorldClim/TRMM/ERA5 or climate presets)

The script computes:
- Base loads from JAXA land use → Emission factors
- Seasonal factors from rainfall → Runoff physics
- First-flush effects from wash-off power law

INPUTS (All globally available):
================================
1. Land Use Map (JAXA ALOS-2/PALSAR or Sentinel-2)
   - Can be generated by generate_synthetic_landuse.py for demo
   
2. Monthly Rainfall (mm) - One of:
   - Climate preset (Mekong, RedRiver, Ganges, etc.)
   - Custom 12-value array from WorldClim/ERA5
   - Auto-fetch from API (future feature)

OUTPUTS:
========
1. lateral_sources.csv        - Base loads (dry season reference)
2. lateral_seasonal_factors.csv - Monthly Q and concentration multipliers
3. point_sources.csv          - City sewage (optional)

SCIENTIFIC BASIS:
=================
- Export Coefficients: Garnier et al. (2005), Kroeze et al. (2002)
- Runoff-Concentration: Horton overland flow + first-flush wash-off
- JAXA Mapping: Based on ALOS-2 25m land cover classification

COMPARISON WITH OTHER MODELS:
=============================
| Model    | Method                  | This Script's Equivalent |
|----------|-------------------------|-------------------------|
| SWAT     | Process-based soil/crop | Simplified EMC approach |
| Delft3D  | Time-varying .tim files | seasonal_factors.csv    |
| MIKE     | NAM rainfall-runoff     | Rainfall → Q_Factor     |
| NEWS     | Export coefficients     | JAXA_EMISSIONS table    |

References:
- Garnier et al. (2005) Biogeochemistry 77, 213-242
- MRC (2018) State of Basin Report - Mekong hydrology
- JAXA ALOS-2 Land Use/Cover Map documentation

Author: Nguyen Truong An
Date: December 2025
"""

import argparse
import os
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import pandas as pd
import numpy as np
from datetime import datetime

# ==============================================================================
# CONFIGURATION
# ==============================================================================

SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent
DEFAULT_CASE_DIR = PROJECT_ROOT / "INPUT" / "Cases" / "Mekong_Delta_Full"

# Grid spacing (from topology)
DX_M = 2000.0  # Grid cell size [m]

# ==============================================================================
# GLOBAL DATASETS: JAXA LAND USE → EMISSION FACTORS
# ==============================================================================
# 
# This table maps JAXA LULC classes to C-GEM water quality parameters.
# EMC = Event Mean Concentration represents pollution intensity.
# Runoff_C = Rational method runoff coefficient (dimensionless).
#
# === UPDATED December 2025 ===
# - Added CH4 and N2O emissions based on Mekong Delta literature
# - Increased TOC values to match Mar 2025 validation (observed: 140-200 µM)
# - Added AT (alkalinity) for carbonate system validation
#
# References:
# - Urban EMC: Burton & Pitt (2002) Stormwater Effects Handbook
# - Rice EMC: Yan et al. (2003) Agriculture, Ecosystems & Environment
# - Rice CH4: Borges & Abril (2011), Maher et al. (2013), MRC (2018)
# - Aquaculture: Páez-Osuna (2001) Environment International
# - Aquaculture CH4: Yang et al. (2019) Aquaculture Environment Interactions
# - Mangrove: Alongi (2014) Annual Review of Marine Science
# - N2O from agriculture: Seitzinger & Kroeze (1998), Garnier et al. (2007)

# Unit conversions for reference:
# TOC: 1 µM = 0.012 mg/L (as C), so 150 µM ≈ 1.8 mg/L (as C) or ~6 mg/L (as organic matter)
# Actually: TOC in mg/L = µmol/L × 12 g/mol / 1000 = µmol/L × 0.012
# BUT: C-GEM uses µmol/L directly, so we need to convert mg/L → µmol/L
# TOC_µM = TOC_mg_L / 12 × 1000 = TOC_mg_L × 83.3

# CH4: 1 nmol/L = 16 ng/L = 0.000016 mg/L
# N2O: 1 nmol/L = 44 ng/L = 0.000044 mg/L

JAXA_EMISSIONS = {
    # =========================================================================
    # URBAN: High NH4/TOC from sewage, moderate CH4 from anaerobic sewers
    # =========================================================================
    "Urban": {
        "NH4": 15.0,    # Sewage leakage, pet waste (increased from 10)
        "NO3": 5.0,     # Fertilized lawns, septic (increased from 3)
        "PO4": 2.0,     # Detergents, sewage (increased from 1.5)
        "TOC": 150.0,   # Organic waste, sewage (INCREASED 3x based on validation)
        "DIC": 40.0,    # Concrete weathering, sewage CO2 (increased)
        "AT": 2000.0,   # Alkalinity from concrete, detergents [µeq/L]
        "SPM": 150.0,   # Construction sediment
        "CH4": 800.0,   # Anaerobic sewers, septic tanks [nmol/L]
                        # Ref: Stanley et al. (2016) - urban streams 200-2000 nmol/L
        "N2O": 50.0,    # WWTP nitrification-denitrification [nmol/L]
                        # Ref: Beaulieu et al. (2011) - urban 20-100 nmol/L
        "Runoff_C": 0.85,
    },
    
    # =========================================================================
    # RICE PADDIES: THE MAJOR CH4 SOURCE IN MEKONG DELTA
    # =========================================================================
    # Rice paddies are flooded anaerobic environments - MAJOR CH4 producers
    # Reference values from:
    # - Borges & Abril (2011): Rice paddy drainage 500-5000 nmol/L CH4
    # - Yang et al. (2018): SE Asian rice paddies 300-2000 nmol/L
    # - MRC (2018): Mekong floodplain CH4 emissions
    "Rice": {
        "NH4": 8.0,     # Urea fertilizer breakdown (increased - major N source)
        "NO3": 10.0,    # Nitrified fertilizer (increased for N2O production)
        "PO4": 1.5,     # Phosphate fertilizer (increased)
        "TOC": 200.0,   # Straw decomposition, dissolved organic C (MAJOR increase)
                        # Ref: Rice paddy DOC typically 150-300 µmol/L
        "DIC": 80.0,    # High respiration in flooded soils
        "AT": 1500.0,   # Carbonate from fertilizer, soil minerals [µeq/L]
        "SPM": 100.0,   # Tillage erosion, resuspension
        "CH4": 1500.0,  # CRITICAL: Rice paddy drainage - highest CH4 source [nmol/L]
                        # Literature: 500-3000 nmol/L in drainage water
                        # Mekong validation shows 100-200 nmol/L upstream
        "N2O": 80.0,    # Nitrification-denitrification in rice soils [nmol/L]
                        # Ref: Mekong agricultural areas 30-175 nmol/L
        "Runoff_C": 0.40,  # Bunded paddies retain water
    },
    
    # =========================================================================
    # AQUACULTURE: High organic load, significant CH4 from pond sediments
    # =========================================================================
    # Aquaculture ponds in Mekong Delta are major pollution sources
    # Reference: Páez-Osuna (2001), Boyd & Tucker (1998)
    "Aqua": {
        "NH4": 12.0,    # Fish excretion, uneaten feed (increased)
        "NO3": 4.0,     # Some nitrification in ponds
        "PO4": 3.0,     # Feed phosphorus (increased)
        "TOC": 250.0,   # High organic load from feed, feces (MAJOR increase)
                        # Aquaculture effluent TOC: 200-400 µmol/L typical
        "DIC": 100.0,   # High respiration in ponds
        "AT": 2500.0,   # Lime addition for pH control, shell dissolution [µeq/L]
        "SPM": 200.0,   # Pond sediment resuspension
        "CH4": 1200.0,  # Anaerobic pond sediments [nmol/L]
                        # Ref: Yang et al. (2019) - shrimp ponds 500-2000 nmol/L
        "N2O": 60.0,    # Coupled nitrification-denitrification [nmol/L]
        "Runoff_C": 0.70,  # Direct discharge during harvest
    },
    
    # =========================================================================
    # MANGROVE: Tidal carbon export, moderate CH4 from sediments
    # =========================================================================
    # Mangroves are carbon-rich but also have anoxic sediments
    # Reference: Alongi (2014), Maher et al. (2013)
    "Mangrove": {
        "NH4": 0.5,     # N sink but some mineralization
        "NO3": 0.2,     # Strong N sink (denitrification)
        "PO4": 0.2,     # P burial
        "TOC": 180.0,   # Major carbon export via tidal flushing (increased)
                        # Mangrove DOC export: 100-300 µmol/L
        "DIC": 120.0,   # High respiration + carbonate dissolution
        "AT": 2200.0,   # Carbonate-rich mangrove soils [µeq/L]
        "SPM": 60.0,    # Fine sediment, some trapping
        "CH4": 400.0,   # Moderate - sulfate reduction competes with methanogenesis [nmol/L]
                        # Ref: Mangrove waters 100-800 nmol/L CH4
        "N2O": 15.0,    # Low - denitrification goes to N2 [nmol/L]
        "Runoff_C": 0.90,  # Tidal flushing
    },
    
    # =========================================================================
    # FRUIT ORCHARDS: Moderate fertilizer use
    # =========================================================================
    "Fruit": {
        "NH4": 5.0,     # Moderate fertilizer
        "NO3": 12.0,    # Higher NO3 from orchards (increased)
        "PO4": 1.5,     # Phosphate application
        "TOC": 80.0,    # Leaf litter, prunings (increased)
        "DIC": 30.0,    # Soil respiration
        "AT": 1200.0,   # Natural soil alkalinity [µeq/L]
        "SPM": 80.0,    # Exposed soil erosion
        "CH4": 100.0,   # Low - aerobic soils [nmol/L]
        "N2O": 40.0,    # Fertilizer-derived N2O [nmol/L]
        "Runoff_C": 0.30,  # Tree cover reduces runoff
    },
    
    # =========================================================================
    # FOREST: Natural background, low emissions
    # =========================================================================
    "Forest": {
        "NH4": 0.5,     # Minimal
        "NO3": 0.8,     # Natural background
        "PO4": 0.08,    # Weathering only
        "TOC": 50.0,    # Leaf litter leachate (increased slightly)
        "DIC": 20.0,    # Soil respiration
        "AT": 800.0,    # Natural background [µeq/L]
        "SPM": 25.0,    # Low erosion
        "CH4": 50.0,    # Low - aerobic forest soils [nmol/L]
        "N2O": 10.0,    # Natural soil N2O [nmol/L]
        "Runoff_C": 0.15,  # High infiltration
    },
}

# ==============================================================================
# CLIMATE PRESETS: MONTHLY RAINFALL (mm)
# ==============================================================================
#
# These presets allow users to quickly set up models for common regions.
# Data sources: WorldClim, TRMM, ERA5 climatology
# Format: [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]

CLIMATE_PRESETS = {
    # Mekong Delta (Southern Vietnam) - MRC data
    # Peak: September, Dry: Jan-Apr
    "Mekong": {
        "rainfall_mm": [15, 8, 20, 55, 180, 260, 290, 310, 340, 270, 130, 45],
        "description": "Mekong Delta, Vietnam (Monsoon tropical)",
        "dry_months": [0, 1, 2, 3],  # Jan-Apr (0-indexed)
    },
    
    # Red River Delta (Northern Vietnam) - Earlier monsoon
    "RedRiver": {
        "rainfall_mm": [20, 28, 45, 95, 190, 260, 290, 320, 220, 120, 55, 25],
        "description": "Red River Delta, Vietnam (Subtropical monsoon)",
        "dry_months": [0, 1, 2, 11],  # Jan-Mar, Dec
    },
    
    # Saigon-Dong Nai (Southern Vietnam)
    "SaigonDongNai": {
        "rainfall_mm": [12, 5, 15, 50, 200, 280, 300, 290, 320, 260, 120, 40],
        "description": "Saigon-Dong Nai basin, Vietnam",
        "dry_months": [0, 1, 2, 3],
    },
    
    # Ganges-Brahmaputra Delta (Bangladesh/India)
    "Ganges": {
        "rainfall_mm": [10, 20, 35, 60, 150, 280, 350, 320, 280, 160, 40, 15],
        "description": "Ganges-Brahmaputra Delta, Bangladesh",
        "dry_months": [0, 1, 2, 11],
    },
    
    # Niger Delta (Nigeria) - Bimodal rainfall
    "Niger": {
        "rainfall_mm": [25, 40, 100, 180, 250, 350, 380, 300, 340, 250, 80, 30],
        "description": "Niger Delta, Nigeria (Equatorial)",
        "dry_months": [0, 1, 11],
    },
    
    # Irrawaddy (Myanmar)
    "Irrawaddy": {
        "rainfall_mm": [5, 10, 25, 50, 200, 450, 550, 500, 350, 180, 60, 15],
        "description": "Irrawaddy Delta, Myanmar (Strong monsoon)",
        "dry_months": [0, 1, 2, 3, 11],
    },
    
    # Mediterranean (dry summer) - for comparison
    "Mediterranean": {
        "rainfall_mm": [80, 70, 55, 45, 30, 15, 8, 12, 35, 70, 90, 95],
        "description": "Mediterranean climate (wet winter)",
        "dry_months": [5, 6, 7],  # Jun-Aug
    },
}

# ==============================================================================
# PHYSICS: RAINFALL → SEASONAL FACTORS
# ==============================================================================

def calculate_seasonal_factors(
    rainfall_mm: List[float],
    dry_months: List[int] = None,
    wash_off_exponent: float = 0.25,
    dilution_threshold: float = 5.0,
) -> pd.DataFrame:
    """
    Convert monthly rainfall (mm) to Q and concentration factors.
    
    Physics:
    --------
    1. Flow Factor (Q_Factor):
       Q_ratio = Rain_month / Rain_dry_base
       This represents relative runoff intensity.
       
    2. Concentration Factor (C_Factor):
       Uses wash-off power law: C = a * Q^b
       - Rising limb (Q < threshold): First flush effect, C increases
       - Peak flow (Q > threshold): Dilution effect, C decreases
       
    Parameters:
    -----------
    rainfall_mm : list of 12 floats
        Monthly rainfall [Jan, Feb, ..., Dec]
    dry_months : list of int, optional
        Indices of dry season months (0=Jan, 11=Dec). Default: [0,1,2]
    wash_off_exponent : float
        Power law exponent for first flush (typically 0.2-0.4)
    dilution_threshold : float
        Q_factor above which dilution dominates
        
    Returns:
    --------
    DataFrame with columns: Month, Rain_mm, Q_Factor, and species factors
    
    === UPDATED December 2025 ===
    Added CH4_Factor, N2O_Factor, AT_Factor, DIC_Factor for GHG validation
    """
    if dry_months is None:
        dry_months = [0, 1, 2]  # Jan-Mar default
    
    # Calculate dry season base rainfall
    dry_rain = [rainfall_mm[i] for i in dry_months]
    base_rain = max(5.0, np.mean(dry_rain))  # Minimum 5mm to avoid division by zero
    
    records = []
    month_names = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    
    for month_idx, rain in enumerate(rainfall_mm):
        # 1. Flow Factor = Rain / Base_Rain (with minimum of 1.0)
        q_factor = max(1.0, rain / base_rain)
        
        # 2. Concentration factors based on wash-off physics
        # Different species respond differently to flow
        
        if q_factor < dilution_threshold:
            # Rising limb: First flush wash-off (concentration increases with flow)
            # C ~ Q^b where b > 0
            base_c_factor = q_factor ** wash_off_exponent
            
            nh4_factor = base_c_factor * 1.0    # NH4: moderate wash-off
            no3_factor = base_c_factor * 0.8    # NO3: less particulate
            po4_factor = base_c_factor * 1.2    # PO4: more particulate-bound
            toc_factor = base_c_factor * 1.3    # TOC: strong wash-off
            spm_factor = base_c_factor * 1.5    # SPM: strongest wash-off
            
            # === NEW: GHG species factors (December 2025) ===
            # CH4: Highest during wet season - flooded rice paddies produce most CH4
            # Also correlates with flooding/waterlogging which creates anoxic conditions
            ch4_factor = base_c_factor * 1.8   # Strong increase with flooding
            
            # N2O: Complex - moderate wash-off, affected by fertilizer application
            # Peak often in transition periods (wet soils but not flooded)
            n2o_factor = base_c_factor * 1.2   # Moderate wash-off
            
            # DIC: Increases with soil respiration during wet season
            dic_factor = base_c_factor * 1.1   # Slight increase
            
            # AT (Alkalinity): Weathering increases with runoff
            at_factor = base_c_factor * 0.9    # Slight dilution initially
            
        else:
            # Peak flow: Dilution dominates for most species
            # C ~ Q^(-c) where c > 0
            peak_c = dilution_threshold ** wash_off_exponent
            dilution_power = 0.4
            
            dilution = (dilution_threshold / q_factor) ** dilution_power
            
            nh4_factor = peak_c * dilution * 0.9
            no3_factor = peak_c * dilution * 0.7   # Strong dilution
            po4_factor = peak_c * dilution * 1.0
            toc_factor = peak_c * 1.1              # TOC stays high (organic flush)
            spm_factor = peak_c * 1.3              # SPM continues increasing
            
            # === NEW: GHG species during high flow ===
            # CH4: REMAINS HIGH during wet season - rice paddies flooded!
            # This is different from soluble species that dilute
            ch4_factor = peak_c * 1.5              # CH4 production INCREASES with flooding
            
            # N2O: Dilution but still elevated from agricultural runoff
            n2o_factor = peak_c * dilution * 1.0
            
            # DIC: Moderate increase from respiration
            dic_factor = peak_c * 1.0
            
            # AT: Dilution during very high flow
            at_factor = peak_c * dilution * 0.85
        
        # Determine season
        if month_idx in dry_months:
            season = "dry"
        elif q_factor > 3.0:
            season = "wet"
        else:
            season = "transition"
        
        records.append({
            "Month": month_idx + 1,
            "Month_Name": month_names[month_idx],
            "Season": season,
            "Rain_mm": rain,
            "Q_Factor": round(q_factor, 3),
            "NH4_Factor": round(nh4_factor, 3),
            "NO3_Factor": round(no3_factor, 3),
            "PO4_Factor": round(po4_factor, 3),
            "TOC_Factor": round(toc_factor, 3),
            "SPM_Factor": round(spm_factor, 3),
            # NEW GHG factors
            "CH4_Factor": round(ch4_factor, 3),
            "N2O_Factor": round(n2o_factor, 3),
            "DIC_Factor": round(dic_factor, 3),
            "AT_Factor": round(at_factor, 3),
        })
    
    return pd.DataFrame(records)


def calculate_daily_factors(
    monthly_factors: pd.DataFrame,
    duration_days: int = 365,
    start_month: int = 1,
) -> pd.DataFrame:
    """
    Interpolate monthly factors to daily resolution for C-code.
    
    Uses smooth interpolation to avoid step changes at month boundaries.
    
    Parameters:
    -----------
    monthly_factors : DataFrame
        Output from calculate_seasonal_factors()
    duration_days : int
        Number of days to generate
    start_month : int
        Starting month (1-12)
        
    Returns:
    --------
    DataFrame with columns: Day, Month, Q_Factor, NH4_Factor, etc.
    """
    # Days per month (non-leap year)
    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    # Build daily factors with linear interpolation
    records = []
    current_month = start_month - 1  # 0-indexed
    day_in_month = 0
    
    for day in range(duration_days):
        # Get current and next month factors
        curr_factors = monthly_factors.iloc[current_month]
        next_month = (current_month + 1) % 12
        next_factors = monthly_factors.iloc[next_month]
        
        # Linear interpolation weight
        month_progress = day_in_month / days_in_month[current_month]
        
        # Interpolate each factor
        record = {
            "Day": day,
            "Day_of_Year": (day + (start_month - 1) * 30) % 365,
            "Month": current_month + 1,
            "Season": curr_factors["Season"],
        }
        
        for col in ["Q_Factor", "NH4_Factor", "NO3_Factor", "PO4_Factor", 
                    "TOC_Factor", "SPM_Factor", "CH4_Factor", "N2O_Factor",
                    "DIC_Factor", "AT_Factor"]:
            if col in curr_factors and col in next_factors:
                interp_val = (1 - month_progress) * curr_factors[col] + \
                             month_progress * next_factors[col]
                record[col] = round(interp_val, 4)
        
        records.append(record)
        
        # Advance day
        day_in_month += 1
        if day_in_month >= days_in_month[current_month]:
            day_in_month = 0
            current_month = next_month
    
    return pd.DataFrame(records)


# ==============================================================================
# SPATIAL: LAND USE MAP → BASE LOADS
# ==============================================================================

def load_landuse_map(case_dir: Path) -> pd.DataFrame:
    """Load the land use map CSV."""
    path = case_dir / "landuse_map.csv"
    if not path.exists():
        raise FileNotFoundError(
            f"Land use map not found: {path}\n"
            "Run generate_synthetic_landuse.py first, or provide JAXA/Sentinel data."
        )
    return pd.read_csv(path)


def calculate_base_loads(
    landuse_df: pd.DataFrame,
    base_runoff_rate: float = 0.002,  # m³/s/km² dry season baseflow
) -> pd.DataFrame:
    """
    Calculate base (dry season) lateral loads from land use.
    
    The output represents the "reference" load that will be multiplied
    by seasonal factors during simulation.
    
    === UPDATED December 2025 ===
    - Added CH4, N2O, AT (alkalinity) columns for GHG validation
    - Increased TOC values based on Mekong Mar 2025 validation
    - Units: mg/L for nutrients/TOC, nmol/L for CH4/N2O, µeq/L for AT
    
    Parameters:
    -----------
    landuse_df : DataFrame
        Land use map with columns: Branch, Distance_km, Segment_Area_km2,
        Pct_Urban, Pct_Rice, Pct_Aqua, Pct_Mangrove, Pct_Fruit
    base_runoff_rate : float
        Dry season runoff rate [m³/s/km²]
        
    Returns:
    --------
    DataFrame with columns: Branch, Segment_Index, Distance_km, Q_lat_base,
        NH4_conc_base, NO3_conc_base, TOC, CH4, N2O, AT, etc.
    """
    records = []
    
    # All species to track (including new GHG species)
    all_species = ["NH4", "NO3", "PO4", "TOC", "DIC", "SPM", "CH4", "N2O", "AT"]
    
    for _, row in landuse_df.iterrows():
        branch = row["Branch"]
        dist_km = row["Distance_km"]
        area_km2 = row.get("Segment_Area_km2", 2.0)  # Default 2 km²
        
        # Calculate grid index
        segment_idx = int(dist_km * 1000 / DX_M)
        
        # Calculate composite EMC based on land use percentages
        # C_composite = Σ (Pct_i × EMC_i) / 100
        conc_mix = {sp: 0.0 for sp in all_species}
        runoff_c_mix = 0.0
        
        for lu_type, emissions in JAXA_EMISSIONS.items():
            col_name = f"Pct_{lu_type}"
            if col_name in row and row[col_name] > 0:
                fraction = row[col_name] / 100.0
                for sp in all_species:
                    if sp in emissions:
                        conc_mix[sp] += fraction * emissions[sp]
                runoff_c_mix += fraction * emissions["Runoff_C"]
        
        # Ensure minimum runoff coefficient
        if runoff_c_mix < 0.1:
            runoff_c_mix = 0.1
        
        # Calculate base flow [m³/s] = Area × Runoff_rate × Runoff_C
        q_base = area_km2 * base_runoff_rate * runoff_c_mix
        
        # Identify polder zones (rice + aquaculture dominated)
        pct_polder = row.get("Pct_Rice", 0) + row.get("Pct_Aqua", 0)
        is_polder = pct_polder > 50.0
        
        records.append({
            "Branch": branch,
            "Segment_Index": segment_idx,
            "Distance_km": dist_km,
            "Area_km2": area_km2,
            "Runoff_C": round(runoff_c_mix, 3),
            "Is_Polder_Zone": is_polder,
            "Q_lat_base_m3_s": round(q_base, 6),
            # Traditional species (mg/L)
            "NH4_conc_base_mg_L": round(conc_mix["NH4"], 2),
            "NO3_conc_base_mg_L": round(conc_mix["NO3"], 2),
            "PO4_conc_base_mg_L": round(conc_mix["PO4"], 2),
            "TOC_conc_base_mg_L": round(conc_mix["TOC"], 2),
            "DIC_conc_base_mg_L": round(conc_mix["DIC"], 2),
            "SPM_conc_base_mg_L": round(conc_mix["SPM"], 2),
            # NEW: GHG species (nmol/L for CH4/N2O, µeq/L for AT)
            "CH4_conc_base_nM": round(conc_mix["CH4"], 1),
            "N2O_conc_base_nM": round(conc_mix["N2O"], 1),
            "AT_conc_base_ueq_L": round(conc_mix["AT"], 0),
        })
    
    return pd.DataFrame(records)


# ==============================================================================
# POINT SOURCES: CITIES AND INDUSTRIAL DISCHARGES
# ==============================================================================

# Major cities in the Mekong Delta
POINT_SOURCES_MEKONG = {
    "Can_Tho": {
        "branch": "Hau_River",
        "distance_km": 80.0,
        "population": 1_500_000,
        "treatment_level": "primary",  # 30% removal
    },
    "My_Tho": {
        "branch": "My_Tho",
        "distance_km": 40.0,
        "population": 500_000,
        "treatment_level": "none",
    },
    "Ben_Tre": {
        "branch": "Ham_Luong",
        "distance_km": 45.0,
        "population": 200_000,
        "treatment_level": "none",
    },
    "Vinh_Long": {
        "branch": "Co_Chien",
        "distance_km": 60.0,
        "population": 150_000,
        "treatment_level": "none",
    },
}

# Per-capita emission rates for CALCULATING MASS LOADS (g/person/day)
# These are NOT concentrations - they are total daily emissions per person
# References: WHO guidelines, Metcalf & Eddy, IPCC
# === UPDATED December 2025: Added CH4 and N2O ===
# === FIXED December 2025: Changed to typical sewage concentrations ===

# TYPICAL RAW SEWAGE CONCENTRATIONS (mg/L)
# These are what actually enters the river, NOT per-capita loads
# Reference: Metcalf & Eddy (2014), Henze et al. (2008)
SEWAGE_CONCENTRATIONS = {
    "NH4": 40.0,     # mg N/L - typical raw sewage
    "NO3": 1.0,      # mg N/L - minimal in raw sewage
    "PO4": 8.0,      # mg P/L - typical raw sewage
    "TOC": 200.0,    # mg C/L - typical raw sewage BOD ~250 → TOC ~200
    "DIC": 100.0,    # mg C/L - from respiration
    "SPM": 250.0,    # mg/L - typical TSS
    # GHG in sewage/sewer systems
    # Reference: Guisasola et al. (2008), Foley et al. (2010)
    "CH4": 5.0,      # mg/L CH4 in sewer headspace equilibrated water
    "N2O": 0.01,     # mg/L N2O from sewer denitrification
}

# Per-capita wastewater generation and emission factors
# Used for calculating MASS LOADS (for load inventories)
PERCAPITA_EMISSIONS = {
    "NH4": 12.0,   # ~12g N/person/day
    "NO3": 1.0,    # Minimal (mostly NH4)
    "PO4": 2.0,    # ~2g P/person/day
    "TOC": 80.0,   # ~80g BOD/person/day → TOC
    "DIC": 40.0,   # Respiration CO2
    "SPM": 50.0,   # Fecal solids
    "CH4": 0.05,   # g CH4/person/day
    "N2O": 0.002,  # g N2O/person/day
}

# Treatment removal efficiencies
TREATMENT_REMOVAL = {
    "none": {"NH4": 0.0, "NO3": 0.0, "PO4": 0.0, "TOC": 0.0, "SPM": 0.0, "CH4": 0.0, "N2O": 0.0},
    "primary": {"NH4": 0.1, "NO3": 0.0, "PO4": 0.1, "TOC": 0.3, "SPM": 0.5, "CH4": 0.1, "N2O": 0.05},
    "secondary": {"NH4": 0.6, "NO3": 0.2, "PO4": 0.3, "TOC": 0.8, "SPM": 0.9, "CH4": 0.5, "N2O": 0.3},
    "tertiary": {"NH4": 0.9, "NO3": 0.8, "PO4": 0.9, "TOC": 0.95, "SPM": 0.95, "CH4": 0.8, "N2O": 0.7},
}


def generate_point_sources(
    point_source_dict: dict = None,
    per_capita_water_L_day: float = 150.0,
) -> pd.DataFrame:
    """
    Generate point source file for major cities.
    
    === UPDATED December 2025: Added CH4 and N2O columns ===
    === FIXED December 2025: Use actual sewage concentrations ===
    
    Parameters:
    -----------
    point_source_dict : dict, optional
        Dictionary of point sources (default: POINT_SOURCES_MEKONG)
    per_capita_water_L_day : float
        Per-capita wastewater generation [L/person/day]
        
    Returns:
    --------
    DataFrame with point source specifications including GHG species
    """
    if point_source_dict is None:
        point_source_dict = POINT_SOURCES_MEKONG
    
    records = []
    
    for name, data in point_source_dict.items():
        pop = data["population"]
        treatment = data.get("treatment_level", "none")
        removal = TREATMENT_REMOVAL[treatment]
        
        # Calculate flow [m³/s]
        q_m3_s = pop * per_capita_water_L_day / 1000.0 / 86400.0
        
        # === FIXED: Use actual sewage concentrations, not per-capita loads ===
        # Apply treatment removal to sewage concentrations
        conc = {}
        for sp, sewage_conc in SEWAGE_CONCENTRATIONS.items():
            conc[sp] = sewage_conc * (1 - removal.get(sp, 0))
        
        # Convert CH4 and N2O from mg/L to nmol/L
        # CH4: MW = 16 g/mol, so mg/L → mmol/L = mg/L / 16, → nmol/L = × 1e6
        # N2O: MW = 44 g/mol
        ch4_nmol_L = conc.get("CH4", 0) / 16.0 * 1e6  # Convert to nmol/L
        n2o_nmol_L = conc.get("N2O", 0) / 44.0 * 1e6  # Convert to nmol/L
        
        segment_idx = int(data["distance_km"] * 1000 / DX_M)
        
        records.append({
            "Name": name,
            "Branch": data["branch"],
            "Segment_Index": segment_idx,
            "Distance_km": data["distance_km"],
            "Population": pop,
            "Treatment": treatment,
            "Q_m3_s": round(q_m3_s, 4),
            "NH4_mg_L": round(conc["NH4"], 1),
            "NO3_mg_L": round(conc["NO3"], 1),
            "PO4_mg_L": round(conc["PO4"], 1),
            "TOC_mg_L": round(conc["TOC"], 1),
            "DIC_mg_L": round(conc.get("DIC", 0), 1),
            "SPM_mg_L": round(conc["SPM"], 1),
            # NEW: GHG columns
            "CH4_nmol_L": round(ch4_nmol_L, 1),
            "N2O_nmol_L": round(n2o_nmol_L, 1),
        })
    
    return pd.DataFrame(records)


# ==============================================================================
# MAIN GENERATION FUNCTION
# ==============================================================================

def generate_all_files(
    case_dir: Path,
    climate: str = "Mekong",
    custom_rainfall: List[float] = None,
    duration_days: int = 365,
    include_point_sources: bool = True,
    base_runoff_rate: float = 0.002,
    representative_landuse: str = None,
) -> Dict[str, pd.DataFrame]:
    """
    Generate all lateral load input files for C-GEM.
    
    Parameters:
    -----------
    case_dir : Path
        Case directory containing landuse_map.csv
    climate : str
        Climate preset name or "custom" for custom rainfall
    custom_rainfall : list, optional
        12 monthly rainfall values [mm] if climate="custom"
    duration_days : int
        Number of days for daily factor file
    include_point_sources : bool
        Whether to generate point sources file
    base_runoff_rate : float
        Dry season runoff [m³/s/km²]
    representative_landuse : str, optional
        Representative land use percentages. Format: "Rice,70;Urban,10;Aqua,15;Fruit,5"
        If provided, overrides landuse_map.csv with uniform land use.
        
    Returns:
    --------
    Dictionary of generated DataFrames
    """
    print("=" * 70)
    print("C-GEM LATERAL LOAD GENERATOR (Rainfall-Driven v2)")
    print("=" * 70)
    
    outputs = {}
    
    # -------------------------------------------------------------------------
    # 1. Get rainfall data
    # -------------------------------------------------------------------------
    if custom_rainfall is not None:
        if len(custom_rainfall) != 12:
            raise ValueError("custom_rainfall must have exactly 12 values")
        rainfall_mm = custom_rainfall
        dry_months = [0, 1, 2]  # Default dry months
        print(f"\nUsing CUSTOM rainfall data")
    elif climate in CLIMATE_PRESETS:
        preset = CLIMATE_PRESETS[climate]
        rainfall_mm = preset["rainfall_mm"]
        dry_months = preset["dry_months"]
        print(f"\nUsing climate preset: {climate}")
        print(f"  Description: {preset['description']}")
    else:
        raise ValueError(f"Unknown climate preset: {climate}. "
                        f"Available: {list(CLIMATE_PRESETS.keys())}")
    
    print(f"  Rainfall (mm): {rainfall_mm}")
    print(f"  Annual total: {sum(rainfall_mm)} mm")
    print(f"  Dry months: {[i+1 for i in dry_months]}")
    
    # -------------------------------------------------------------------------
    # 2. Generate seasonal factors
    # -------------------------------------------------------------------------
    print("\nCalculating seasonal factors from rainfall physics...")
    monthly_factors = calculate_seasonal_factors(rainfall_mm, dry_months)
    
    # Save monthly factors
    monthly_path = case_dir / "lateral_seasonal_factors.csv"
    monthly_factors.to_csv(monthly_path, index=False)
    outputs["monthly_factors"] = monthly_factors
    print(f"  Saved: {monthly_path}")
    
    # Show summary
    print("\n  Monthly Factors:")
    print(monthly_factors[["Month_Name", "Rain_mm", "Q_Factor", "NH4_Factor", 
                          "TOC_Factor"]].to_string(index=False))
    
    # Generate daily interpolated factors
    print(f"\n  Generating daily factors ({duration_days} days)...")
    daily_factors = calculate_daily_factors(monthly_factors, duration_days)
    daily_path = case_dir / "lateral_daily_factors.csv"
    daily_factors.to_csv(daily_path, index=False)
    outputs["daily_factors"] = daily_factors
    print(f"  Saved: {daily_path}")
    
    # -------------------------------------------------------------------------
    # 3. Generate base loads from land use
    # -------------------------------------------------------------------------
    
    landuse_df = None
    
    # Check for representative land use mode
    if representative_landuse:
        print("\n*** REPRESENTATIVE LAND USE MODE ***")
        print(f"  Using uniform land use: {representative_landuse}")
        print("  This applies the same land use percentages to ALL segments.")
        print("  Useful for data-sparse applications or sensitivity studies.")
        
        # Parse representative land use string: "Rice,70;Urban,10;Aqua,15;Fruit,5"
        landuse_pct = {}
        for item in representative_landuse.split(";"):
            parts = item.strip().split(",")
            if len(parts) == 2:
                lu_type = parts[0].strip()
                pct = float(parts[1].strip())
                landuse_pct[lu_type] = pct
        
        # Validate land use types
        for lu_type in landuse_pct.keys():
            if lu_type not in JAXA_EMISSIONS:
                print(f"  Warning: Unknown land use type '{lu_type}'. Available: {list(JAXA_EMISSIONS.keys())}")
        
        total_pct = sum(landuse_pct.values())
        if abs(total_pct - 100.0) > 1.0:
            print(f"  Warning: Land use percentages sum to {total_pct}% (should be 100%)")
        
        # Load topology to get branch names and lengths
        try:
            topo_path = case_dir / "topology.csv"
            topo_df = pd.read_csv(topo_path, comment='#', skipinitialspace=True)
            # Clean column names
            topo_df.columns = [c.strip() for c in topo_df.columns]
            
            # Find branch name and length columns
            name_col = [c for c in topo_df.columns if 'name' in c.lower()][0]
            length_col = [c for c in topo_df.columns if 'length' in c.lower()][0]
            
            # Generate uniform landuse_df
            records = []
            for _, row in topo_df.iterrows():
                branch_name = str(row[name_col]).strip()
                length_m = float(row[length_col])
                num_segments = max(1, int(length_m / (DX_M * 2)))  # 2km segments
                
                for seg in range(num_segments):
                    dist_km = seg * DX_M * 2 / 1000.0
                    record = {
                        "Branch": branch_name,
                        "Distance_km": dist_km,
                        "Area_km2": 2.0,  # Default 2 km² per segment
                    }
                    # Add land use percentages
                    for lu_type in JAXA_EMISSIONS.keys():
                        col_name = f"Pct_{lu_type}"
                        record[col_name] = landuse_pct.get(lu_type, 0.0)
                    records.append(record)
            
            landuse_df = pd.DataFrame(records)
            print(f"  Generated {len(landuse_df)} segments from topology")
            print(f"  Land use: {landuse_pct}")
            
        except Exception as e:
            print(f"  Error generating representative land use: {e}")
            print("  Falling back to landuse_map.csv...")
            landuse_df = None
    
    # Load from file if not using representative mode
    if landuse_df is None:
        print("\nLoading land use map...")
        try:
            landuse_df = load_landuse_map(case_dir)
            print(f"  Loaded {len(landuse_df)} segments from "
                  f"{len(landuse_df['Branch'].unique())} branches")
        except FileNotFoundError as e:
            print(f"  Warning: {e}")
            print("  Skipping base load generation.")
            return outputs
    
    print("\nCalculating base loads from JAXA emissions...")
    base_loads = calculate_base_loads(landuse_df, base_runoff_rate)
    
    # Save base loads
    base_path = case_dir / "lateral_sources.csv"
    base_loads.to_csv(base_path, index=False)
    outputs["base_loads"] = base_loads
    print(f"  Saved: {base_path}")
    
    # Summary by branch
    print("\n  Base loads by branch (dry season reference):")
    summary = base_loads.groupby("Branch").agg({
        "Q_lat_base_m3_s": "sum",
        "Area_km2": "sum",
    })
    summary["Q_m3_day"] = summary["Q_lat_base_m3_s"] * 86400
    print(summary[["Area_km2", "Q_m3_day"]].round(1).to_string())
    
    # -------------------------------------------------------------------------
    # 4. Generate point sources
    # -------------------------------------------------------------------------
    if include_point_sources:
        print("\nGenerating point sources (cities)...")
        point_sources = generate_point_sources()
        
        point_path = case_dir / "point_sources.csv"
        point_sources.to_csv(point_path, index=False)
        outputs["point_sources"] = point_sources
        print(f"  Saved: {point_path}")
        
        print("\n  Point Sources:")
        print(point_sources[["Name", "Branch", "Population", "Q_m3_s", 
                            "NH4_mg_L", "TOC_mg_L"]].to_string(index=False))
    
    # -------------------------------------------------------------------------
    # 5. Final summary
    # -------------------------------------------------------------------------
    print("\n" + "=" * 70)
    print("GENERATION COMPLETE")
    print("=" * 70)
    print("\nFiles generated:")
    print(f"  1. {monthly_path.name} - Monthly Q and concentration factors")
    print(f"  2. {daily_path.name} - Daily interpolated factors")
    print(f"  3. {base_path.name} - Base loads (dry season reference)")
    if include_point_sources:
        print(f"  4. {point_path.name} - City point sources")
    
    print("\nC-CODE USAGE:")
    print("  1. At initialization: Load lateral_sources.csv (base loads)")
    print("  2. At initialization: Load lateral_seasonal_factors.csv (monthly) OR")
    print("                        lateral_daily_factors.csv (daily interpolation)")
    print("  3. At each timestep:")
    print("     Q_lat = Q_lat_base × Q_Factor(month)")
    print("     C_lat = C_lat_base × Species_Factor(month)")
    
    return outputs


# ==============================================================================
# COMMAND LINE INTERFACE
# ==============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Generate rainfall-driven lateral loads for C-GEM",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Use Mekong climate preset (default)
  python generate_lateral_loads_v2.py
  
  # Use Red River climate
  python generate_lateral_loads_v2.py --climate RedRiver
  
  # Custom rainfall (12 values in mm)
  python generate_lateral_loads_v2.py --rainfall 10,5,15,40,150,250,300,320,350,280,100,30
  
  # Show available climate presets
  python generate_lateral_loads_v2.py --list-presets
  
  # Custom case directory
  python generate_lateral_loads_v2.py --case-dir INPUT/Cases/MyCase

Climate Presets Available:
  Mekong        - Mekong Delta, Vietnam (monsoon tropical)
  RedRiver      - Red River Delta, Vietnam (subtropical monsoon)
  SaigonDongNai - Saigon-Dong Nai basin, Vietnam
  Ganges        - Ganges-Brahmaputra Delta, Bangladesh
  Niger         - Niger Delta, Nigeria (equatorial)
  Irrawaddy     - Irrawaddy Delta, Myanmar (strong monsoon)
  Mediterranean - Mediterranean climate (dry summer)
        """
    )
    
    parser.add_argument(
        "--climate", "-c",
        type=str,
        default="Mekong",
        help="Climate preset name (default: Mekong)"
    )
    parser.add_argument(
        "--rainfall", "-r",
        type=str,
        default=None,
        help="Custom monthly rainfall as comma-separated values (12 values in mm)"
    )
    parser.add_argument(
        "--case-dir", "-d",
        type=str,
        default=None,
        help="Path to case directory"
    )
    parser.add_argument(
        "--duration",
        type=int,
        default=365,
        help="Duration in days for daily factor file (default: 365)"
    )
    parser.add_argument(
        "--no-point-sources",
        action="store_true",
        help="Skip point source generation"
    )
    parser.add_argument(
        "--representative-landuse", "-R",
        type=str,
        default=None,
        help="Use representative land use instead of detailed map. Format: 'Rice,80;Urban,10;Fruit,10'"
    )
    parser.add_argument(
        "--list-presets",
        action="store_true",
        help="List available climate presets and exit"
    )
    parser.add_argument(
        "--base-runoff",
        type=float,
        default=0.002,
        help="Dry season base runoff rate [m³/s/km²] (default: 0.002)"
    )
    
    args = parser.parse_args()
    
    # List presets
    if args.list_presets:
        print("\nAvailable Climate Presets:")
        print("-" * 70)
        for name, preset in CLIMATE_PRESETS.items():
            print(f"\n{name}:")
            print(f"  Description: {preset['description']}")
            print(f"  Rainfall (mm): {preset['rainfall_mm']}")
            print(f"  Annual total: {sum(preset['rainfall_mm'])} mm")
            print(f"  Dry months: {[i+1 for i in preset['dry_months']]}")
        print("\n\nAvailable Land Use Types for --representative-landuse:")
        print("-" * 70)
        for lu_type in JAXA_EMISSIONS.keys():
            print(f"  {lu_type}")
        print("\nExample: --representative-landuse 'Rice,70;Urban,10;Aqua,15;Fruit,5'")
        return
    
    # Parse custom rainfall
    custom_rainfall = None
    if args.rainfall:
        try:
            custom_rainfall = [float(x.strip()) for x in args.rainfall.split(",")]
            if len(custom_rainfall) != 12:
                raise ValueError("Must provide exactly 12 values")
        except Exception as e:
            print(f"Error parsing rainfall: {e}")
            return
    
    # Set case directory
    case_dir = Path(args.case_dir) if args.case_dir else DEFAULT_CASE_DIR
    
    # Generate files
    generate_all_files(
        case_dir=case_dir,
        climate=args.climate if custom_rainfall is None else "custom",
        custom_rainfall=custom_rainfall,
        duration_days=args.duration,
        include_point_sources=not args.no_point_sources,
        base_runoff_rate=args.base_runoff,
        representative_landuse=args.representative_landuse,
    )


if __name__ == "__main__":
    main()
